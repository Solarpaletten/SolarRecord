/**
 * PDF Generation for Transcripts
 * DashkaRecord v2.0.0-alpha - Phase 3
 * 
 * Uses pdfkit for PDF creation
 */

import PDFDocument from 'pdfkit';
import { promises as fs } from 'fs';
import { createWriteStream } from 'fs';
import path from 'path';
import { RecordingMetadata } from './types';
import { getRecordingPaths } from './storage';

/**
 * Generate PDF report from transcript
 */
export async function generatePdf(
  recordingId: string,
  metadata: RecordingMetadata,
  transcriptPath: string
): Promise<string> {
  console.log(`üìÑ Generating PDF for ${recordingId}`);

  const paths = getRecordingPaths(recordingId);
  const pdfPath = paths.pdf;

  // Ensure directory exists
  const pdfDir = path.dirname(pdfPath);
  await fs.mkdir(pdfDir, { recursive: true });

  // Read transcript
  const transcriptContent = await fs.readFile(transcriptPath, 'utf-8');
  
  // Parse metadata from transcript
  const lines = transcriptContent.split('\n');
  let language = 'Unknown';
  let confidence = 'N/A';
  let transcriptText = transcriptContent;
  
  if (lines[0].startsWith('[Language:')) {
    language = lines[0].replace('[Language:', '').replace(']', '').trim();
    if (lines[1] && lines[1].startsWith('[Confidence:')) {
      confidence = lines[1].replace('[Confidence:', '').replace(']', '').trim();
      transcriptText = lines.slice(3).join('\n');
    } else {
      transcriptText = lines.slice(2).join('\n');
    }
  }

  return new Promise((resolve, reject) => {
    try {
      // Create PDF document
      const doc = new PDFDocument({
        size: 'A4',
        margins: {
          top: 72,
          bottom: 72,
          left: 72,
          right: 72,
        },
      });

      const stream = createWriteStream(pdfPath);
      doc.pipe(stream);

      // ===== HEADER =====
      doc
        .fontSize(24)
        .fillColor('#2563eb')
        .text('Solar Recorder', { align: 'center' });

      doc.moveDown(0.5);

      doc
        .fontSize(14)
        .fillColor('#1e40af')
        .text('Transcript Report', { align: 'center' });

      doc.moveDown(2);

      // ===== METADATA TABLE =====
      doc.fontSize(10).fillColor('#000000');

      const metadataLines = [
        `Recording ID: ${recordingId}`,
        `Date: ${new Date(metadata.createdAt).toLocaleString()}`,
        `Language: ${language}`,
        `Confidence: ${confidence}`,
        `File: ${metadata.filename}`,
      ];

      if (metadata.durationSeconds) {
        metadataLines.push(`Duration: ${formatDuration(metadata.durationSeconds)}`);
      }

      if (metadata.fileSizeBytes) {
        const sizeMB = (metadata.fileSizeBytes / (1024 * 1024)).toFixed(2);
        metadataLines.push(`Size: ${sizeMB} MB`);
      }

      // Draw metadata box
      const metadataY = doc.y;
      doc
        .rect(72, metadataY, 450, metadataLines.length * 15 + 20)
        .fillAndStroke('#e0e7ff', '#2563eb');

      doc.fillColor('#000000');
      let currentY = metadataY + 10;
      for (const line of metadataLines) {
        doc.text(line, 80, currentY);
        currentY += 15;
      }

      doc.moveDown(2);

      // ===== TRANSCRIPT HEADING =====
      doc
        .fontSize(12)
        .fillColor('#1e40af')
        .text('Transcript', { underline: true });

      doc.moveDown(1);

      // ===== TRANSCRIPT CONTENT =====
      doc
        .fontSize(11)
        .fillColor('#000000');

      // Split into paragraphs
      const paragraphs = transcriptText.trim().split('\n\n');
      
      for (const para of paragraphs) {
        if (para.trim()) {
          // Escape special characters
          const cleanPara = para.replace(/[<>&]/g, (char) => {
            switch (char) {
              case '<': return '&lt;';
              case '>': return '&gt;';
              case '&': return '&amp;';
              default: return char;
            }
          });

          doc.text(cleanPara, {
            align: 'justify',
            lineGap: 4,
          });

          doc.moveDown(0.5);
        }
      }

      // ===== FOOTER =====
      doc.moveDown(2);

      doc
        .fontSize(9)
        .fillColor('#666666')
        .text('Generated by Solar Recorder | AI | IT | Solar', {
          align: 'center',
        });

      // Finalize PDF
      doc.end();

      stream.on('finish', () => {
        console.log(`‚úÖ PDF generated: ${pdfPath}`);
        resolve(pdfPath);
      });

      stream.on('error', (error) => {
        console.error('‚ùå PDF generation error:', error);
        reject(error);
      });
    } catch (error) {
      console.error('‚ùå PDF generation error:', error);
      reject(error);
    }
  });
}

/**
 * Format duration in seconds to human-readable format
 */
function formatDuration(seconds: number): string {
  const hours = Math.floor(seconds / 3600);
  const minutes = Math.floor((seconds % 3600) / 60);
  const secs = Math.floor(seconds % 60);
  
  if (hours > 0) {
    return `${hours}h ${minutes}m ${secs}s`;
  } else if (minutes > 0) {
    return `${minutes}m ${secs}s`;
  } else {
    return `${secs}s`;
  }
}

/**
 * Check if PDFKit is available
 */
export async function checkPdfAvailability(): Promise<boolean> {
  try {
    // Try to import pdfkit
    await import('pdfkit');
    return true;
  } catch {
    console.error('‚ùå pdfkit not installed. Run: npm install pdfkit @types/pdfkit');
    return false;
  }
}
